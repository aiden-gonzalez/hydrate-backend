import {
  ColumnType,
  Generated,
  Insertable,
  // JSONColumnType,
  Selectable,
  Updateable
} from "kysely";
import {IHashedPassword, ILocation} from "../utils/types";
import {IUserProfile} from "../profiles/types";
import {IFobInfo, IRatingDetails} from "../fobs/types";

export interface Database {
  fob: FobTable,
  fob_change: FobChangeTable,
  rating: RatingTable,
  user: UserTable,
  picture: PictureTable,
  fob_with_rating: FobWithRatingView
}

type DbCreatedAt = ColumnType<number, number, never>
type DbUpdatedAt = ColumnType<number, number, number>

// Should only be used in the "Database" type above, never as a result of a query
export interface FobTable {
  // Keep in mind, columns that are generated by the database should be marked using the "Generated" type.
  // This way they are automatically made optional in inserts and updates.
  id: string
  user_id: string
  name: string
  // You can specify JSON columns using the `JSONColumnType` wrapper.  It is a shorthand for
  // `ColumnType<T, string, string>`, where T is the type of the JSON object/array retrieved from the database,
  // and the insert and update types are always `string` since you're always stringifying insert/update values.
  // However. I want to insert and update as ILocation here as well, so I'm not using that shorthand.
  location: ColumnType<ILocation, ILocation, ILocation>
  info: ColumnType<IFobInfo, IFobInfo, IFobInfo>
  // You can specify a different type for each operation (select, insert and update) using the
  // `ColumnType<SelectType, InsertType, UpdateType>` wrapper. Here we define a column `created_at`
  // that is selected as a `Date`, can be provided as a Date in inserts and can never be updated
  created_at: DbCreatedAt
  // Same but updated with Date
  updated_at: DbUpdatedAt
}

// You should not use the table schema interfaces directly. Instead, you should
// use the `Selectable`, `Insertable` and `Updateable` wrappers. These wrappers
// make sure that the correct types are used in each operation.
//
// Most of the time you should trust the type inference and not use explicit
// types at all. These types can be useful when typing function arguments.
export type Fob = Selectable<FobTable>
export type NewFob = Insertable<FobTable>
export type FobUpdate = Updateable<FobTable>

export interface FobWithRatingView {
  id: string,
  user_id: string,
  name: string,
  location: ColumnType<ILocation, ILocation, ILocation>,
  info: ColumnType<IFobInfo,  IFobInfo, IFobInfo>,
  created_at: DbCreatedAt,
  updated_at: DbUpdatedAt,
  average_rating: number
}

export type FobWithRating = Selectable<FobWithRatingView>

export interface FobChangeTable {
  id: Generated<number>
  fob_id: string
  user_id: string
  details: object
  changed_at: DbCreatedAt
}

export type FobChange = Selectable<FobChangeTable>
export type NewFobChange = Insertable<FobChangeTable>

export interface RatingTable {
  id: string
  fob_id: string
  user_id: string
  details: ColumnType<IRatingDetails, IRatingDetails, IRatingDetails>
  created_at: DbCreatedAt
  updated_at: DbUpdatedAt
}

export type Rating = Selectable<RatingTable>
export type NewRating = Insertable<RatingTable>
export type RatingUpdate = Updateable<RatingTable>

export interface UserTable {
  id: string
  username: string
  email: string
  hashed_password: ColumnType<IHashedPassword, IHashedPassword, IHashedPassword>
  profile: ColumnType<IUserProfile, IUserProfile, IUserProfile>
  created_at: DbCreatedAt
  updated_at: DbUpdatedAt
}

export type User = Selectable<UserTable>
export type NewUser = Insertable<UserTable>
export type UserUpdate = Updateable<UserTable>

export interface PictureTable {
  id: string
  fob_id: string
  user_id: string
  url: string
  created_at: DbCreatedAt
  updated_at: DbUpdatedAt
}

export type Picture = Selectable<PictureTable>
export type NewPicture = Insertable<PictureTable>
export type PictureUpdate = Updateable<PictureTable>

export type UserContributions = {
  fobs: Fob[],
  ratings: Rating[],
  pictures: Picture[]
}
