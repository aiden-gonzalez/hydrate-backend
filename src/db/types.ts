import {
    ColumnType,
    Generated,
    Insertable,
    JSONColumnType,
    Selectable,
    Updateable
} from "kysely";
import {ILocation} from "../utils/types";

export interface Database {
    fob: FobTable,
    rating: RatingTable,
    user: UserTable,
    picture: PictureTable
}

type DbCreatedAt = ColumnType<Date, Date, never>
type DbUpdatedAt = ColumnType<Date, Date, Date>
type DbRatingDetail = 1 | 2 | 3 | 4 | 5

// Should only be used in the "Database" type above, never as a result of a query
export interface FobTable {
    // Keep in mind, columns that are generated by the database should be marked using the "Generated" type.
    // This way they are automatically made optional in inserts and updates.
    id: string
    user_id: string
    // You can specify JSON columns using the `JSONColumnType` wrapper.  It is a shorthand for
    // `ColumnType<T, string, string>`, where T is the type of the JSON object/array retrieved from the database,
    // and the insert and update types are always `string` since you're always stringifying insert/update values.
    info: JSONColumnType<{
        name: string
        bottle_filler: boolean
        location: ILocation
    } | {
        name: string
        gender: 'male' | 'female' | 'unisex'
        sanitary_products: boolean
        baby_changer: boolean
        location: ILocation
    }>
    // You can specify a different type for each operation (select, insert and update) using the
    // `ColumnType<SelectType, InsertType, UpdateType>` wrapper. Here we define a column `created_at`
    // that is selected as a `Date`, can be provided as a Date in inserts and can never be updated
    created_at: DbCreatedAt
    // Same but updated with Date
    updated_at: DbUpdatedAt
}

// You should not use the table schema interfaces directly. Instead, you should
// use the `Selectable`, `Insertable` and `Updateable` wrappers. These wrappers
// make sure that the correct types are used in each operation.
//
// Most of the time you should trust the type inference and not use explicit
// types at all. These types can be useful when typing function arguments.
export type Fob = Selectable<FobTable>
export type NewFob = Insertable<FobTable>
export type FobUpdate = Updateable<FobTable>

export interface RatingTable {
    id: string
    fob_id: string
    user_id: string
    details: JSONColumnType<{
        pressure: DbRatingDetail
        taste: DbRatingDetail
        temperature: DbRatingDetail
    } | {
        cleanliness: DbRatingDetail
        decor: DbRatingDetail
        drying: DbRatingDetail
        privacy: DbRatingDetail
        washing: DbRatingDetail
    }>
    created_at: DbCreatedAt
    updated_at: DbUpdatedAt
}

export type Rating = Selectable<RatingTable>
export type NewRating = Insertable<RatingTable>
export type RatingUpdate = Updateable<RatingTable>

export interface UserTable {
    id: string
    username: string
    email: string
    hashed_password: JSONColumnType<{
        hash_pass: string
        hash_salt: string
    }>
    profile: JSONColumnType<{
        full_name: string
        picture_link: string
    }>
    created_at: DbCreatedAt
    updated_at: DbUpdatedAt
}

export type User = Selectable<UserTable>
export type NewUser = Insertable<UserTable>
export type UserUpdate = Updateable<UserTable>

export interface PictureTable {
    id: string
    entity_id: string
    user_id: string
    url: string
    created_at: DbCreatedAt
    updated_at: DbUpdatedAt
}

export type Picture = Selectable<PictureTable>
export type NewPicture = Insertable<PictureTable>
export type PictureUpdate = Updateable<PictureTable>
